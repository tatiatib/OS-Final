net_raid_client.c - პარსავს config_file ს და სტარტავს storage ების შესაბამისი რაოდენობის შვილობილ პროცესს.

fuse_raid.h - აერთიანებს raid_1 და raid_5 სთვის შემავალი fuse ის ფუნქციებს და აღწერს მათ საერთო 
			  სტრუქტურას.
fuse_raid_1.c - იძახებს fuse_main ს net_raid_client იდან გადაცემული შესაბამისი დირექტორიით და აკეთებს fuse
				სთვის საჭირო სისქოლების "გადატვირთვას" Raid_1 ს შესაბამისი ლოგიკით . 


fuse_raid_5.c - იძახებს fuse_main ს და აკეთებს raid 5 ს შესაბამის წერას და კითხვას სერვერზე. {
				(ფუნქციონალურად იგივე რაც fuse_raid_1.c)

utils.c - 	fuse_raid_1 და fuse_raid_5 სთვის საჭირო ფუქნციები.

net_raid_server.c - იღებს კლიენტის შესაბამის მესიჯს და რეალურად არსებულ დირექტორიაში აკეთებს მესიჯის 						შესაბამის სისქოლს.

utils_server.c  - სერვერისთვის დამხმარე ფუქნციების რეალიზაცია.
==============================================================
#net_raid_client

კლიენტი კითხულობს კონფიგურაციის ფაილს და storage ების მიხედვით აკეთებს შვილობილ პროცესს, ანუ 2 სხვადასხვა 
storage ის შემთხევაში იქნება 2 fork, თითოეული პასუხისმგებელი მხოლოდ შესაბამის დამაუნთებულ დირექტორიაზე.

თითოეული storage სთვის fuse ეშვება, როგორც foreground პროცესი და მესიჯები მიმდინარე მოქმედებების შესახებ, ანუ რომელ სისქოლს იძახებს კლიენტი და რომელ სერვერს გადაეცემა შესაბამისი სისქოლის მესიჯი გამოაქვს აუთფუთად 
[​Sun​ ​ Jun​ ​ 10​ ​ 12​ : ​ 30​ :37​ ​ 2018​] ​ STORAGE1 ​ 127.0.0.1:10001 open connection  ფორმატში.



--- იმპლემენტაციის დეტალები ---
1. საჭიროა, რომ fuse ში "გადატვირთულ" ყველა სისქოლს ჰქონდეს, საერთო მეხსირება (სოკეტების დესკრიპტორები, ip, port, timeout, diskname). ამისათვის გამოყენებულია fuse_main ში არსებული მეოთხე პარამეტრი, რომელიც default ად არის NULL და წარმოადგენს fuse ში არსებული struct fuse_contextის private_data field ს.
შესაბამისად ყოველი სისქოლის დროს საჭიროა ამ სტრუქტურის ამოღება შესაბამისი ფუქნციით - fuse_get_context();
და შემდეგ მისი private_data არის ჩვენი გადაცემული პარამეტრი. ამ შემთხევაში ეს პარამეტრი არის სტრუქტურა

struct auxdata{
	int * sds;    //სოკეტების დესკრიპტორები
	int sd_numb;  //სოკეტების დესკრიპტორების რაოდენობა
	int timeout;  //timeout ის ზომა
	char * diskname;	//STORAGE ის სახელი
	int errorlog;		//error log ფაილის დესკტიპტორი
	addresses * ip_ports;	 //სერვერების ip-ports
	addresses * swap_ip_port;
};


######### fuse_raid_1 ##############
struct restore_entry {
   	char * path;
    UT_hash_handle hh;         
};

struct restore_entry * restore_list = NULL;  //ლისტი რომელიც ინახავს ფაილების სახელებს, რომელთა შეცვლაც მოხდა რომელიმე გათიშული სერვერის მოლოდინის დროს და საჭიროა მათი restore ამ სერვერზე.


რომელიც აღწერილია fuse_raid.h ში.


თითოეული სისქოლი უკავშირდება სერვერს და სერვერიდან მიღებულ ინფორმაცის აბრუნებს, როგორც შედეგს fuse ის სისქოლის. 
იმის გამო, რომ ხშირად პარამეტრი რომელიც საჭიროა, რომ სერვერს გავუგზავნოთ არის path , და რომელიც ცვლადი ზომის არის, სტრუქტურის გაგზავნა და სტრუქტურის მიღება არაოპტიმალური იქნებოდა, იმიტომ რომ path ის როგორც char * ის სტრუქტურაში აღწერა შეიძლება მხოლოდ როგორც მისამართი, (კლიენტისთვის არსებული მისამართი გამოუსადეგარი იქნებოდა სერვერისთვის), ან როგორც char ების კონსტანტა ზომის მასივი, რომელიც ასევე ცუდი გადაწყვეტაა, იმიტომ რომ path კონსტანტა ზომის ვერ იქნება, შესაბამისად ყოველ გაგზავნაზე საჭიროა იმ data ს სერიალიზაცია ერთი დიდ მეხსიერებად და შემდეგ ამ პაკეტის გაგზავნა. თითოეული სისქოლს ( უმეტესობას ), განსვავებული პარამეტრები აქვს გადასაცემი სერვერისთვის, მაგალითად read აგზავნის  fh(უკვე გახსნილი ფაილის დესკტიპტორს, შესაძელებელია path ის გაგზავნაც), offset, size  და getattr აგზავსის მხოლოდ path, ამიტომ ყველას სხვადასხვა მიდგომა სჭირდება. (ასევეა სერვერიდან მიღებული პაკეტის დამუშავებაც).

getattr  - გამოიძახება fuse ის ნებისმიერი ფუნქციის წინ. მისი შესაბამისი სისქოლის სერვერის მხარეს არის stat. 

open, release - აგზავნის ორივე სერვერზე open ის შესაბამის request ს და იღებს სერვერიდან გახსნილი ფაილის დესკრიპტორს, რომელიც ინახება struct fuse_file_info* fi ს fh field ად, რომელიც საშუალებას იძლევა path ის გამოყენების გარეშე fd ები ვუგზავნოთ სერვერს რადგან, fuse თვითონ ინახავს ამ path ზე დესკრიპტორებს. გვაქვს  ორი სერვერი  და საჭიროა თითოეულის დაბრუნებული fd ები შევინახოთ, fd არის 4 ბაიტი, fi->fh არის 8 ბაიტი, შესაბამისად ორივე სერვერის დესკრიპტორი ამ field ში ეტევა. გარდა ამისა, fuse აქვს თავისი ქეში, რომლის გამოყენებაც ხდება fi->keep_cache = 1;-ით ფაილის გახსნისას და თუ ფაილში არაფერი შეცვლილა, read ის გამოძახების გარეშე აბრუნებს ფაილის content ს.  თუ კი რომელიმე სერვერზე, ფაილი არ დაემთხვა hash ს  -  სერვერი გზავნის შესაბამის მესიჯს
და კლიენტი უზრუნველყოფს იმას, რომ მოხდეს ამ ფაილის restore სერვერზე, რომელზეც დაზიანებული იყო.

read - წაკითხვა ხდება მხოლოდ ერთი სერვერიდან (კერძოც config file ში აღწერილი პირველი სერვერიდან) და მეორე სერვერზე უბრალოდ იგზავნება  keep alive message , რომელიც არის 4 ბაიტი და რომელიც საჭიროა იმისთვის, რომ დავრწმუნდეთ, მუდმივი კითხვის შემთხევაში, როდესაც მხოლოდ პირველი სერვერი იყო დატვირთული, მეორე სერვერიც ჩართულია და ფუნქციონირებს.

create, unlink, mkdir, rmdir - request იგზავნება ორივე სერვერზე.

write - ორივე სერვერზე გზავნის შესაბამის bufferს, fd, offset, size ს და სერვერები აბრუნებებენ hash ებს, თუ ჰეშები ერთმანეთს არ დაემთხვა გამოაქვს შესაბამისი მესიჯი. 

truncate - raid 1 ში შესაძლებელია ფაილის ცვლილება, არამხოლოდ append ს საშუალებით და ამას უზრუნველყოფს truncate, რადგანაც ეს სისქოლიც ცვლის ფაილის კონტენტს, თავიდან ხდება ჰეშის დათვლა და write ის მსგავსად სერვერები აბრუნებენ ჰეშებს, რადგან მოხდეს ამ ჰეშების შედარება და დარწმუნება, რომ ცვლილები ერთნაირად განხორციელდა.

opendir, releasedir - fuse ისთვის, ამ ორი სისქოლის "გადატვირთვას" დიდი მნიშვნელობა არ აქვს, თუმცა სერვერებზე მაინც ხდება მათი შესაბამისი რეალური სისქოლების გამოძახება. სერვერის მხარეს opendir აბრუნებს მისამართს DIR * ტიპის, რომელიც ეგზავნება კლიენტს და კლიენტი ისევე როგორც ფაილების შემთხევაში  struct fuse_file_info ს fi ფილდში ინახავს ამ მისამართს.  releasdir ს დროს მისამართი უკან უბრუნდება სერვერს და იხურება დირექტორია.

net_readdir - სერვერის მხარეს იგზავნება request  დირექტორიის სახელით, სერვერი კითხულობს დირექტორიის შიგთავსს და გზავნის სახელებს, მას შემდეგ რაც კითხვა დამთავრდება გზავნის მესიჯს 0, რაც იმას ნიშნავს, რომ კლიენტი რომელიც while ში ელოდებოდა ახალ სახელს რათა filler ფუნქციით fuse ს გადმოცემულ buf ში ჩაეწერა, უნდა მორჩეს.

utime, chmod, chown - იმისთვის რომ, touch filename მა იმუშაოს საჭიროა utime, იმისთვის, რომ mv source dest და cp source dest მა იმუშაოს საჭიროა chmod  და chown.

destroy - გამოიძახება მას შემდეგ რაც მომხმარებელი კლიენტს გათიშავს (ctrl-c), ერთგვარი signal hanlder ია fuse  სთვის და  ხდება მეხსიერების გასუფთავება, მაგალითად ip port ების თვის გამოყოფილი მეხსირების free.

HOTSWAP -- RAID1

თუ სერვერმა კლიენტის მიერ გაგზავნილ მესიჯზე შესაბამისი პასუხი არ გამოგზავნა (მიღებული buffer ს ზომა არის 0),
config_file ში აღწერილი წამების განმავლობაში, სერვერი ცდილობს კლიენთან დაკავშირებას. დაკავშირება ეშვება ცალკე thread ში, იმისთვის რომ, ამ დროის განმავლობაში შესაძლებელი იყოს ls, read, write, getattr, ყველა დანარჩენი სისქოლის შესრულება უგულებელყოფილია და შესაბამისი მესიჯი იბეჭდება კლიენტის output ზე.  თუ კი ფაილი შეიცვალა მაშინ როდესაც სერვერის ჩართვას ელოდებოდა, ეს ფაილი ხვდება restore_file ს ლისტში, და იმ შემთხვევაში თუ გათიშულ სერვერთან კონტაქტი აღდგება მხოლოდ ამ ლისტში მოთავასებული ფაილების restore მოხდება, რაც იმას გულისხმობს, რომ სერვერზე რომელზეც რეალურად ჩაიწერა content გაუგზავნის აღდგენილ სერვერს.


თუ დროის გასვლის შემდეგ გათიშული სერვერი არ ჩაირთო, ჯერ მოწმდება hostwap სერვერი დაკავშირებულია თუ არა
(keep_alive message ის საშუალებით) და შემდეგ ეგზავნება მესიჯი clear, რაც იმას გულისხმობს, რომ თავისი დირექტორია უნდა გაასუფთავოს (თუ კი hotswap მანამდეც იყო გამოყენებული, მასში შენახული იქნება ფაილები, რომლებიც საჭირო არ არის), ხოლოს სერვერს ეგზავნება მესიჯი dump და სერვერი იწყებს მასზე დამაუნთებული დირექტორიის ქვეხეში არსებული ფაილების და დირექტორიების შესახებ ინფორმაციის  და შიგთავსის გაგზავნას კლიენტისთვის, რომელიც თავის მხრივ უგზავნის hotswap ს. საბოლოოდ იგზავნება მესიჯი რომელიც ნიშნავს იმას, რომ მთელი ხე გაგზავნილია და წესით სერვერზე და hotswap ზე იდენტური მდგომარეობა უნდა იყოს.


როდესაც სერვერი გათიშულად გამოცხადდება, hostwap და სერვერი ცვლიან ადგილებს და ახლა უკვე გათიშული სერვერია hotswap.
გათიშულ სერვერთან დაკავშირების მცდელობა მოხდება მხოლოდ მაშინ, თუ hotswap იც მწყობრიდან გამოვიდა და თუ კავშირი აღდგენილი იქნება, განმეორდება იგივე მესიჯები რაც პირველად hotswap თან დაკავშირებისას გაიგზავნა.


#####fuse_raid_5#####



--- net_raid_server.c ---

თითოეული კლიენტის შეერთება ეშვება ცალკე thread ში და მუდმივ რეჟიმში ელოდება request ს კლიენტისგან. სისქოლებს აქვს მაიდენთიფიცირებელი ნომრები, მაგალითად getattr- ის ნომერი არის 0 და სერვერზე ამ syscall number ის შესაბამისი ფუნქცია გამოიძახება, რომელიც მიღებულ დატას დაამუშავებს და სისქოლს გამოიძახებს და შედეგს ისევ კლიენტს დაუბრუნებს. server აერთიანებს raid 1 ს და raid 5 ის ფუნქციონალს , იმიტომ რომ ფუნქციების უმეტესობა იგივეა. 

net_write - წერს ფაილში მიღებულ buffer ს და ითვლის ჰეშს file ში არსებულ content ზე. იმისთვის, რომ ყოველ ჩაწერაზე საჭირო არ იყოს ფაილის ბოლომდე წაკითხვა და ჰეშის თავიდან დათვლა, გამოყენებულია hash ფუნქცია, რომელიც საშუალოებას იძლევა მანამდე დათვლილი ჰეში და ახალი მიღებული buffer გამოვიყენოთ, მთლიანი ფაილის ჰეშის დასათვლელად. hash ინახება ფაილის extended attribute ად, თუ ფაილის ზომა არის 0 და unsigned long hash  =  5381,
(const hash_djb სთვის).

unsigned long hash_djb(unsigned char *str, unsigned long hash){
    int c;

    while ((c = *str++)){
        hash = ((hash << 5) + hash) + c; 
    }

    return hash;
}

გარდა ძირითადი სისქოლების რეალიზაციისა, სერვერი აერთიანებს დამხმარე ფუნქციებს raid ების გამართული მუშაობისთვის. მაგალითად 
void net_hostwap_storage(int cfd, char * buf, int type, char * path);  //აგზავნის ხის სტრუქტურას
void net_hotswap_file_content(int cfd, char * buf, int type, char * path); //აგზავნის ხეში არსებულ ფაილების კონტენტს
void net_restore_file(int cfd, char * buf, int type, char * path); //აგზავნის მოთხოვნილი ფაილის კონტენტს








